# тернарный (ternarius — «тройной») оператор — операция, возвращающая свой первый или третий операнд
# в зависимости от значения логического выражения, заданного вторым операндом
# результат 1 если выражение_истинно, иначе результат 2
# вместо конструкции if … else, в которой нет elif
# позволяет писать компактный и читаемый код
# Синтаксис
# name = 'Max' if is_has_name else 'Empty'
# number = 1 if is_one else 2
# print('Привет' if is_russian else 'Hello')
# в общем виде: результат1 если условие иначе результат2

# is_has_name = is_one = is_russian = True
# for i in range(0, 2):
#     print(is_one)
#     name = "Max" if is_has_name else "Empty"
#     print(name)
#     number = 1 if is_one else 2
#     print(number)
#     print("Привет" if is_russian else "Hello")
#     print("-" * 20)
#     is_has_name = is_one = is_russian = False

# Примеры использования
# От if к тернарному оператору
# слово -> СлОвО

# word = "слово"
# result = []
# # вариант 1 - прямолинейный и простой
# for i in range(len(word)):
#     # вариант 1 - прямолинейный и простой
#     # if i % 2:
#     #     letter = word[i].lower()
#     # else:
#     #     letter = word[i].upper()
#     # вариант 2 - тернарный
#     letter = word[i].lower() if i % 2 else word[i].upper()
#     result.append(letter)

# result = "".join(result)
# print(result)

# сразу пишем тернарный оператор
# проверка пароля пользователя

# password = input('Введите пароль :')
# print('Разрешено' if password == 'secret' else 'Запрещено')

# ----------------------------------------------
# В Python существует специальная синтаксическая конструкция,
# которая позволяет по определенным правилам создавать заполненные списки.
# Такие конструкции называются генераторами списков.
# Генераторы словарей можно определить по аналогии.
#
# Применение
# вместо цикла for
# позволяет писать компактный и читаемый код
# работают быстрее
# Синтаксис
# [ number for number in numbers if number > 0 ]
# Преимущества
# компактный и читаемый код
# скорость

# Примеры:
# записать в список только положительные числа
# numbers = [1 , 2, -3, 4, 5, -2, -8, 7]

# # классический способ
# result = []
# for number in numbers:
#     if number > 0:
#         result.append(number)
# print(result)

# # через функцию filter
# result = filter(lambda number: number > 0, numbers)
# print(list(result))

# # через генератор
# result = [number for number in numbers if number > 0]
# print(result)

# # генератор словарей
# pairs = {(1, 'a'), (2, 'b'), (3, 'c')}

# # классический способ
# result = {}
# for pair in pairs:
#     key = pair[0]
#     val = pair[1]
#     result[key] = val
# print(result)
# # через генератор словаря
# result = {pair[0]: pair[1] for pair in pairs}
# print(result)

# Недостатки
# Нельзя заменить очень сложные конструкции.
# При неправильном использовании могут ухудшить читаемость.

# # Примеры
# # Создать список из случайных чисел от 1 до 100.
# import random
# length = 10
# numbers = [ random.randint(1, 100) for i in range(length)]
# print(numbers)

# # Создать список квадратов чисел.
# numbers2 = [number ** 2 for number in numbers]
# print(numbers2)

# # Создать список имен на букву А.
# names = ['Alex', 'Bob', 'Max', 'Ann']
# names = [name for name in names if name.startswith('A')] # ! startswitch
# print(names)

# ----------------------------------------------
# Приведение типов к bool в Python
# Все встроенные типы данных в Python приводятся к логическому типу bool по определенным правилам:
# Истина: 'abc', [1], (1,), {1:'a'}, 10, 1.1, ...
# Ложь: '', [], (), {}, 0, None, ...
# Стиль записи логических выражений
# Из-за данного преобразования типов в Python желательно использовать лаконичный стиль записи логических выражений:
# Вместо if len(str_var) > 0: ...
# Пишем: if str_var: ...
# Это ускоряет разработку и делает код более читаемым.
# s = 'abc'
# # классический способ
# if len(s) != 0:
#     print('Строка не пустая')
# else:
#     print('Строка пустая')

# # удабный python способ
# s = ''
# if s:
#     print('Строка не пустая')
# else:
#     print('Строка пустая')

# # аналогично со списками, словарями и другими типами
# l = [1,4]
# d = {}
# if l or d:
#     print('Список или словарь не пусты')
# else:
#     print('Список и словарь пусты')


# Как работает and
# Оператор and не проверяет следующее логическое выражение если текущее False (ленивый).
# Оператор and возвращает первый ложный элемент или последний истинный.
# import math
# if 1 > 2 and math.sqrt(-1):
#     print('Ошибки не будет, т.к. первое условие - ложь')
# print('Идем дальше')

# # if math.sqrt(-1) and 1 > 2:
# #     print('Если поменять местами - ошибка будет')

# # первая ложь
# print([1] and [] and '' and 1)

# # последняя истина
# print([1] and 1 and 20 and 1.3)


# Как работает or
# Оператор or не проверяет следующее логическое выражение если текущее True (ленивый).
# Оператор or возвращает первый истинный элемент или последний ложный.
# import math
# if 1 < 2 or math.sqrt(-1):
#     print('Ошибки не будет, т.к. первое условие - истина')
# print('Идем дальше')

# # первая истина
# print([] or 0 or 'fg' or 1)

# # последняя ложь
# print([] or 0 or () or {})


# Примеры применения
# and: извлечение квадратного корня из отрицательного числа
# import math

# # Есть список чисел
# numbers = [3, 4, 1, 2, 4, -4, 7, 16]

# # Соpдать список из тех чисел, которые имеют квадратный корень < 2
# result = []
# # Обычный способ
# for number in numbers:
#     if number > 0:
#         sqrt = math.sqrt(number)
#         if sqrt < 2:
#             result.append(number)
# print(result)
# result = []
# # через ленивый and
# for number in numbers:
#     if number > 0 and math.sqrt(number) < 2:
#         result.append(number)
# print(result)
# # через генератор
# result = [number for number in numbers if number > 0 and math.sqrt(number) < 2]
# print(result)


# or: сохранение в переменную одного из 2-х значений
#  добавление элемента в список

# классический способ
# def add_to_list(input_list = None):
#     if input_list is None:
#         input_list = []
#     input_list.append(2)
#     return input_list

# result = add_to_list([0, 1])
# print(result)
# result = add_to_list()
# print(result)

# # через or
# def add_to_list(input_list = None):
#     input_list = input_list or []
#     input_list.append(2)
#     return input_list
# result = add_to_list([0, 1])
# print(result)
# result = add_to_list()
# print(result)

# ----------------------------------------------
# Хранение списков в памяти
# ! При работе со списками стоит помнить, 
# ! что если мы переприсваиваем список в другую переменную a = b и меняем значения внутри нового списка b[1], 
# ! значения изменятся и внутри старого списка a[1], т.к. ссылки на элементы списка остаются на своих местах в памяти 
# ! и каждый список использует одни и те же элементы.

# # анология с числом
# a = 1
# b = a
# b = 100
# # Число a не изменилось
# print(a, b)

# # работа со списком
# a = [1, 2, 3]
# b = a
# b[1] = 100
# # ! Элементы списка a тоже изменились
# print(a) 

# Изменение элементов списка в функции
# ! При передаче списка параметром в функцию нужно быть особенно внимательными: 
# ! функция может изменить элемент списка внутри основной программы.
# numbers = [1, 2, 3]

# def change_number_in_list(input_list):
#     input_list[1] = 200

# change_number_in_list(numbers)
# # ! список в основной программе тоже изменился
# print(numbers)

# Методы копирования списка
# - Создание среза от начала и до конца списка my_list[:]. 
# - Метод copy у самого списка.

# a = [1, 2, 3]
# #  с помощью среза
# b = a[:]
# b[1] = 200
# # список a не изменился
# print(a) 

# #  с помощью среза
# b = a.copy()
# b[1] = 200
# # список a тоже не изменился
# print(a) 

# # ! Эти способы не будут работать если есть вложенные списки
# a = [1, 2, [1, 2]]
# b = a[:]
# b[2][1] = 200
# # список a снова меняется
# print(a)

# b = a.copy()
# b[2][0] = 200
# # список a снова меняется
# print(a)

# Модуль copy
# Применяется для полного (глубокого) копирования списка.
# Используется функция deepcopy.
# b = copy.deepcopy(a).
# import copy

# a = [1, 2, [1, 2]]
# b = copy.deepcopy(a)
# b[2][0] = 200
# print(a, b)


# ----------------------------------------------
# Исключительная ситуация
# Во время выполнения программы могут возникать ситуации, когда состояние внешних данных, 
# устройств ввода-вывода или компьютерной системы в целом делает дальнейшие вычисления 
# в соответствии с базовым алгоритмом невозможными или бессмысленными.
# Обработка исключений
# try:
#     Блок с возможной исключительной ситуацией.
# except:
#     Код, который выполняется при возникновении исключительной      ситуации.
# number = int(input('Input number: '))
# try:
#     number = 100 / number
# except:
#     print('Division by zero')

# Перехват конкретных исключений
# В Python каждая исключительная ситуация имеет свой тип.
# TypeError, ValueError, ...
# Самое общее исключение имеет тип Exception.
# Рекомендуется обрабатывать конкретные исключительные ситуации и реагировать на разные исключения по-разному.

# try:
#     number = int(input('Input number: '))
#     number = 100 / number
# except ZeroDivisionError:
#     print('Попытка деления на 0')
# except Exception:
#     print('Неизвестная ошибка')

# Информация об ошибке
# Можно получить дополнительную информацию об исключении, 
# Если использовать конструкцию except Исключение as e:
# Тогда в переменную e будет сохранен объект исключения.

# try:
#     number = int(input('Input number: '))
#     number = 100 / number
# except ZeroDivisionError as e:
#     print('Попытка деления на 0')
#     print ('Информация об ошибке:', e)
#     print(type(e))
# except Exception as e:
#     print('Неизвестная ошибка')
#     print ('Информация об ошибке:', e)
#     print(type(e))

# try - except - else - finally
# Блок try — код, который может вызвать исключение.
# Блок except — что делать при возникновении исключения.
# Блок else — что делать, если исключения не произошло.
# Блок finally — выполняется всегда.

# number = int(input('Input number: '))
# try:
#     number = 100 / number
# except:
#     print('Попытка деления на 0')
# else:
#     print('Исключения не было')
# finally:
#     print('Делаем что-то в любом случае')


# Генерация исключений
# Иногда требуется не обработать а, наоборот, создать исключительную ситуацию.
# Это можно сделать с помощью команды raise: 
# raise Exception('Что то пошло не так').

print('Начало')
raise Exception('Что-то пошло не так')
print('Конец')  # сюда мы уже не попадем без обработки
