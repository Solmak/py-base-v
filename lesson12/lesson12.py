# -----------------------------------------------------
# Функция open
# открывает файл в указанном режиме
# f = open(‘my.txt’, ‘w’)
# file — имя файла
# mode — режим
# encoding — кодировка

# Режимы открытия mode
# r — чтение
# w — запись, если файла нет, создается новый
# x — запись, если файла нет, ошибка
# a — дозапись
# b — двоичный режим
# + — открытие на чтение и запись

# открываем на запись 
# - файла не существует - будет создан новый 
# ! - если файл существует - ОН БУДЕТ ПЕРЕЗАПИСАН
# f = open('lesson12\\first.txt', 'w')

# открываем на чтение - файла не существует - выдаст ошибку
# f = open('second.txt', 'r')

# открываем на чтение - файл существует
# f = open('lesson12\\first.txt', 'r')

# -----------------------------------------------------
# Запись текста в файл
# write — записать строку в файл, строки не переносятся
# writelines — записать список строк в файл, строки не переносятся
# \n — символ конца строки

# f = open('lesson12\\first.txt', 'w')
# f.write('Hello!\n')
# f.write('World\n')
# f.writelines(['Hello\n','Python\n'])

# -----------------------------------------------------
# Чтение из файла
# read — чтение всего файла
# for line in f: — чтение файла построчно
# readlines — чтение файла в список строк

# f = open('lesson12\\first.txt', 'r')
# print(f.read())   # если не закомментить - не прочитает. Указатель позиции?
# for line in f:
#     print(line.replace('\n', ''))
# print(f.readlines())

# -----------------------------------------------------
# Закрытие файла
# После работы с файлом его необходимо закрывать.
# Открытые файлы тратят ресурсы системы.
# f.close().
# Если до close произойдет исключительная ситуация, файл не будет закрыт.
# Удобным вместо close() является использование with.

# f = open('lesson12\\first.txt', 'r')
# for line in f:
#     print(line.replace('\n', ''))
# f.close()    # надо не забывать закрывать - можно избежать с конструкцией whith

# with open('lesson12\\first.txt', 'r') as f: # закроется автоматически когда закроется whith
#     for line in f:
#         print(line.replace('\n', ''))
# print('end')

# -----------------------------------------------------
# # Типы строк в Python
# # str — обычные строки
# # bytes — строки байт
# # bytearray — изменяемая строка байт

# # создание обычной строки
# s = 'Hello world'
# print(type(s))

# # создание строки байт
# sb = b'Hello bytes'
# print(type(sb))
# print(sb)

# -----------------------------------------------------
# Действия со строками байт. Различия с обычной
# индекс sb[0]
# срез sb[1:3]
# ...

# s = 'Hello world'
# sb = b'Hello bytes'

# print(s[1])
# print(sb[1])
# print(s[1:3])
# print(sb[1:3])

# for item in sb:
#     print(item)

# -----------------------------------------------------
# Как строка хранится в памяти?
# Любая информация хранится в памяти как набор 0 и 1.
# Строки не являются исключением.
# Каждому символу ставится в соответствие определенный код (число).
# Коды могут быть разные и зависят от кодировки.
# sb = b'Ad'

# # по acsii должно получиться 65
# print(sb[0])
# # по acsii должно получиться 100
# print(sb[1])

# -----------------------------------------------------
# Перевод строки в байты (кодирование)
# ‘Hello world’.encode(‘utf-8’).
# При переводе строки str в байты bytes указываем кодировку.
# Кодировка должна поддерживать символы нужного нам алфавита.

# s = 'Hello world Мир'
# sb = s.encode('utf-8')
# print(type(sb))
# print(sb)

# # Перевод байт в строку (декодирование)
# # sb.decode(‘utf-8’).
# # Указываем кодировку, которой мы кодировали строку.
# s1 = sb.decode('utf-8')
# print(type(s1))
# print(s1)

# -----------------------------------------------------
# Работа с файлом в режиме байтов
# open(‘filename’, ‘wb’) — режим записи байтов
# open(‘filename’, ‘rb’) — режим чтения байтов
# параметр encoding определяет кодировку
# open(‘filename’, ‘w’, encoding=’utf-8’)

# # Открываем файл для записи байтов. Кодировка тут не треба, ведь открываем в двоичном виде
# with open('lesson12\\bytes.txt', 'wb') as f: # закроется автоматически когда закроется whith
#     pass
# # Открываем файл для чтения байтов. Кодировка -
# with open('lesson12\\bytes.txt', 'rb') as f: 
#     pass
# # открываем в текстовим виде с указанием кодировки
# with open('lesson12\\bytes.txt', 'r', encoding='utf-8') as f: 
#     pass

# Запись байтов в файл
# f.write(b’some bytes’) — файл открыт в режиме wb
# f.write(‘some str’) — файл открыт в режиме w
# в любом случае информация хранится в виде нулей и единиц

# # Открываем файл для записи байтов. Кодировка тут не треба, ведь открываем в двоичном виде
# with open('lesson12\\bytes.txt', 'wb') as f: 
#     f.write(b'Hello bytes')
# # читаем как текст
# with open('lesson12\\bytes.txt', 'r', encoding='ascii') as f: 
#     print(f.read())
# # Открываем файл для записи байтов.
# with open('lesson12\\bytes.txt', 'wb') as f: 
#     # пишем строку байт
#     str = 'Привет мир'
#     f.write(str.encode('utf-8'))
# # Читаем текст с кодировкой utf-8
# with open('lesson12\\bytes.txt', 'r', encoding='utf-8') as f: 
#     print(f.read())

# Чтение байтов из файла
# f.read() - файл открыт в режиме rb — читаем байты
# f.read() - файл открыт в режиме r — читаем строки

# # Открываем файл для записи байтов.
# with open('lesson12\\bytes.txt', 'wb') as f: 
#     # пишем строку байт
#     str = 'Привет мир'
#     f.write(str.encode('utf-8'))
# # или, что равнозначно:
# # with open('lesson12\\bytes.txt', 'w', encoding='utf-8') as f: 
# #     f.write('Привет мир')

# # Открываем в режиме чтения байт
# with open('lesson12\\bytes.txt', 'rb') as f: 
#     # Читаем байты
#     result = f.read()
#     print(result)
#     print(type(result))
#     s = result.decode('utf-8')
#     print(s)

# -----------------------------------------------------
# Сериализация
# Процесс преобразования объекта в поток байтов для сохранения или передачи в память, базу данных или файл.
# Обратный процесс — десериализация.

# Применение сериализации
# сохранение объекта в файл
# сохранение объекта в базу данных
# передача объекта по сети
# ...
# Способы записи объекта в файл
# ручной (создание велосипеда)
# универсальный - pickle

# Ручной способ
# {‘name’: ‘Max’, ‘phones’: [123, 345]}
# Как перевести такой объект (dict) в байты для сохранения в файл?
# Придумать способ приведения объекта к более простым.
# Придумать свой формат хранения.
# person = {'name': 'Max','phones': [123, 456]}

# # откроем файл
# with open('lesson12\\person.dat', 'wb') as f:
#     # например запишем оъект в файл построчно
#     # сначала имя
#     name = person['name']
#     f.write(f'{name}\n'.encode('utf-8'))
#     # получим телефоны
#     phones = person['phones']
#     # запишем телефоны построчно
#     for phone in phones:
#         f.write(f'{phone}\n'.encode('utf-8'))
# print('Объект записан')

# Теперь пробуем прочитать
# откроем файл
# with open('lesson12\\person.dat', 'rb') as f:
#     # нам надо знать как мы записывали объект
#     # прочитаем файл в список
#     result = f.readlines()

# # теперь воссоздаем исходный объект
# person = {}
# person['name'] = result[0].decode('utf-8').replace('\n', '')
# # далее телефоны
# phones = []
# for bphone in result[1:]:
#     phones.append(bphone.decode('utf-8').replace('\n', ''))

# person['phones'] = phones
# # получили исходный... уффф, а если структура изменится?
# print(person)
# # Ручной способ (Недостатки)
# # Не универсальный.
# # При небольшом изменении объекта изменится весь алгоритм.
# # Надо помнить, как мы делали сохранение, чтобы потом прочитать.
# # Трудоемкий.

# -----------------------------------------------------
# Модуль pickle
# Сохраняет сложные объекты в файл. 
# Преобразует сложные объекты в байты.
# Встроен в Python.
# Основные функции
# dump — сохранение объекта в файл 
# dumps — преобразование объекта в байты
# load — загрузка объекта из файла
# loads — загрузка объекта из набора байт

# import pickle

# person = {'name': 'Max','phones': [123, 456]}

# # Открываем файл для записи
# with open('lesson12\\person.dat', 'wb') as f:
#     # сразу пишем объкт целиком с помощью pickle
#     pickle.dump(person, f)
# print('Объект записан')

# # Читаем что мы там поназаписали
# person1 = None
# with open('lesson12\\person.dat', 'rb') as f:
#     person1 = pickle.load(f)
# print(person1)

# -----------------------------------------------------
# Формат json
# JavaScript Object Notation.
# Текстовый формат обмена данными, основанный на JavaScript.
# Аналогичен набору словарей, списков, простых типов данных в Python.
# Является просто текстом (строкой).
# Применение
# хранение данных
# передача данных
# чаще всего используется в web-разработке для передачи данных по протоколу http
# json в Python
# Основные структуры Python схожи с форматом.
# Требуется только преобразование в строку и обратно.
# Этим занимается модуль json.
# import json.
# json. Основные функции
# dump — сохранение объекта в формате json в файл 
# dumps — преобразование объекта в json (в текст)
# load — загрузка объекта из файла
# loads — загрузка объекта из формата json (строки)

# import json

# friends = [
#     {'name': 'Max', 'age': 23, 'phones': [123,345]},
#     {'name': 'Leo', 'age': 21}
# ]
# # смотри тип
# print(type(friends))

# # Преобразуем в json
# json_friends = json.dumps(friends)
# # смотрим
# print(type(json_friends))
# print(json_friends)

# # обратно из json в объект
# friends1 = json.loads(json_friends)
# print(type(friends1))
# print(friends)

# Как в предыдущем, но в файл
import json

friends = [
    {'name': 'Max', 'age': 23, 'phones': [123,345]},
    {'name': 'Leo', 'age': 21}
]

with open('lesson12\\friends.json', 'w') as f:
    # Преобразуем и сохраняем в файл
    json_friends = json.dump(friends, f)

# # обратно из файла в объект
with open('lesson12\\friends.json', 'r') as f:
    friends = json.load(f)

print(friends)
print(type(friends))

# -----------------------------------------------------
# Задача
# Передать список любимых песен и их исполнителей своему другу, разработчику C#.

import json

favourite_tracks = [
    {'name:': 'Вечная любовь', 'artist': 'Агата Кристи'},
    {'name:': 'Angel', 'artist': 'Massive attack'},
    {'name:': 'Jamming', 'artist': 'Bob Marley'}
]
with open('lesson12\\tracks.json', 'w', encoding='utf-8') as f:
    json.dump(favourite_tracks, f)

print('File saved')
